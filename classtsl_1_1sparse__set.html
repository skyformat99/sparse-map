<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sparse-map: tsl::sparse_set&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sparse-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1sparse__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tsl::sparse_set&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__set_8h_source.html">sparse_set.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a134ffc2e98eb4036ec035dcab3311132"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a134ffc2e98eb4036ec035dcab3311132">key_type</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#adc056738e1cacb38ce79bcb83570295f">ht::key_type</a></td></tr>
<tr class="separator:a134ffc2e98eb4036ec035dcab3311132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2a5c6030d9049c3fa90089c44cce1c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#abf2b27209fb966b4c1bb2a9b079ddd16">ht::value_type</a></td></tr>
<tr class="separator:a7b2a5c6030d9049c3fa90089c44cce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185fabe6ffe0e61cf281fe24dcecb4ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a3f4b430ca8f17193795c6c5e47c2761b">ht::size_type</a></td></tr>
<tr class="separator:a185fabe6ffe0e61cf281fe24dcecb4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89fa803460a78b451a8c13fa332d56e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#af89fa803460a78b451a8c13fa332d56e">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aa2f4501c9b73d199b144bc6184b73fe5">ht::difference_type</a></td></tr>
<tr class="separator:af89fa803460a78b451a8c13fa332d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c26bba78435b5e2ba52439322b1ecc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a27c26bba78435b5e2ba52439322b1ecc">hasher</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a9fca6709214b4c2ced97e25582255437">ht::hasher</a></td></tr>
<tr class="separator:a27c26bba78435b5e2ba52439322b1ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2660bae704edd1f398dfbe2088ed38f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a2660bae704edd1f398dfbe2088ed38f5">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#ab8a7d98af123623e80fdc76508d1ae5a">ht::key_equal</a></td></tr>
<tr class="separator:a2660bae704edd1f398dfbe2088ed38f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd4aa5667d3a2c13c81f65ad0cdcb2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a1fd4aa5667d3a2c13c81f65ad0cdcb2f">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a574a1bee2921d635f4f8f95cbb549df6">ht::allocator_type</a></td></tr>
<tr class="separator:a1fd4aa5667d3a2c13c81f65ad0cdcb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64908d05c7a7d5889afd76531ed80a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#af64908d05c7a7d5889afd76531ed80a5">reference</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a009f29b7ac5f3cd4fcd1d8984884e65c">ht::reference</a></td></tr>
<tr class="separator:af64908d05c7a7d5889afd76531ed80a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465b2d7e7e411b8be32e2144322fad8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a465b2d7e7e411b8be32e2144322fad8c">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a7178624912bef125a419abfdf2660e84">ht::const_reference</a></td></tr>
<tr class="separator:a465b2d7e7e411b8be32e2144322fad8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfe79c23e570b78b5926a1a3289c319"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#addfe79c23e570b78b5926a1a3289c319">pointer</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a7c48ae532848dc06f83746a76f060b7d">ht::pointer</a></td></tr>
<tr class="separator:addfe79c23e570b78b5926a1a3289c319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5e1f0224035d65a46a9496504e2f49"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#aae5e1f0224035d65a46a9496504e2f49">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a487a79ec467016ab14d390c1ac7c5f1b">ht::const_pointer</a></td></tr>
<tr class="separator:aae5e1f0224035d65a46a9496504e2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cd3ae31de1ba6d0e63a9f36f8b2a14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a7bdadb7941c03e0aa1df91787a3306f2">ht::iterator</a></td></tr>
<tr class="separator:a27cd3ae31de1ba6d0e63a9f36f8b2a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4173ab24031bacf64a1d84b57eb56ebf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aee8a233535786e0a96080bb9b0696f07">ht::const_iterator</a></td></tr>
<tr class="separator:a4173ab24031bacf64a1d84b57eb56ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a295f3cff4b99c81bb12798533080d736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a295f3cff4b99c81bb12798533080d736">sparse_set</a> ()</td></tr>
<tr class="separator:a295f3cff4b99c81bb12798533080d736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d46605ff085d7a03a690db6622f21ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7d46605ff085d7a03a690db6622f21ec">sparse_set</a> (<a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a7d46605ff085d7a03a690db6622f21ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e9e08cbcd784657b6ac7f5173ac89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a668e9e08cbcd784657b6ac7f5173ac89">sparse_set</a> (<a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a668e9e08cbcd784657b6ac7f5173ac89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49356b3874bd2c070e3f486daa9d8c29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a49356b3874bd2c070e3f486daa9d8c29">sparse_set</a> (<a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a49356b3874bd2c070e3f486daa9d8c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9295cd2a737df5098cd09ec201c83c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7e9295cd2a737df5098cd09ec201c83c">sparse_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a7e9295cd2a737df5098cd09ec201c83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b7aa97ee125f344349ab9e616ab665"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ac4b7aa97ee125f344349ab9e616ab665"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ac4b7aa97ee125f344349ab9e616ab665">sparse_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>=<a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aca102c8a2a2f3750ce3815eb06da20ac">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:ac4b7aa97ee125f344349ab9e616ab665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeca86f7f3d5c2989aed621efa63a2d3"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:afeca86f7f3d5c2989aed621efa63a2d3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#afeca86f7f3d5c2989aed621efa63a2d3">sparse_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:afeca86f7f3d5c2989aed621efa63a2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1449066a67620ccdba8135120161fd5"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ab1449066a67620ccdba8135120161fd5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ab1449066a67620ccdba8135120161fd5">sparse_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ab1449066a67620ccdba8135120161fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1829a0dbfcb643f6f1e8924f2cbc8a53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a1829a0dbfcb643f6f1e8924f2cbc8a53">sparse_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt; init, <a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>=<a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aca102c8a2a2f3750ce3815eb06da20ac">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a1829a0dbfcb643f6f1e8924f2cbc8a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe15933f44634b22b0f5f4519562856a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#abe15933f44634b22b0f5f4519562856a">sparse_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt; init, <a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:abe15933f44634b22b0f5f4519562856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e942615b4e665c237eb5732017cd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#aa07e942615b4e665c237eb5732017cd5">sparse_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt; init, <a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:aa07e942615b4e665c237eb5732017cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc66404adb78ddce24bc3c163191454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a9dc66404adb78ddce24bc3c163191454">operator=</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a9dc66404adb78ddce24bc3c163191454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d916e767daa8af4521b1eb9a76ef0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a1fd4aa5667d3a2c13c81f65ad0cdcb2f">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a2d916e767daa8af4521b1eb9a76ef0bf">get_allocator</a> () const</td></tr>
<tr class="separator:a2d916e767daa8af4521b1eb9a76ef0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c72a399e8dc6d11ec4b556662908aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7c72a399e8dc6d11ec4b556662908aa8">begin</a> () noexcept</td></tr>
<tr class="separator:a7c72a399e8dc6d11ec4b556662908aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d29d11618e87a80ddbd04467d4a6616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a9d29d11618e87a80ddbd04467d4a6616">begin</a> () const noexcept</td></tr>
<tr class="separator:a9d29d11618e87a80ddbd04467d4a6616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a7d7a2675de91621eca5b87ce4cd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ae1a7d7a2675de91621eca5b87ce4cd17">cbegin</a> () const noexcept</td></tr>
<tr class="separator:ae1a7d7a2675de91621eca5b87ce4cd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9c3e4a3bdbb31d794b5d2bc1d17f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a0da9c3e4a3bdbb31d794b5d2bc1d17f4">end</a> () noexcept</td></tr>
<tr class="separator:a0da9c3e4a3bdbb31d794b5d2bc1d17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aae6b52a13d4789b0ac277e8dad4306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a2aae6b52a13d4789b0ac277e8dad4306">end</a> () const noexcept</td></tr>
<tr class="separator:a2aae6b52a13d4789b0ac277e8dad4306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b70056918da8a673ea4fda6d4275277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a0b70056918da8a673ea4fda6d4275277">cend</a> () const noexcept</td></tr>
<tr class="separator:a0b70056918da8a673ea4fda6d4275277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aeb6636b74bdd55e32071df3a281fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a40aeb6636b74bdd55e32071df3a281fa">empty</a> () const noexcept</td></tr>
<tr class="separator:a40aeb6636b74bdd55e32071df3a281fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03458b16b541626152262a5858e120c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a03458b16b541626152262a5858e120c1">size</a> () const noexcept</td></tr>
<tr class="separator:a03458b16b541626152262a5858e120c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549f788410854345803c9dfb2ad23b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a549f788410854345803c9dfb2ad23b86">max_size</a> () const noexcept</td></tr>
<tr class="separator:a549f788410854345803c9dfb2ad23b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcb30233885d3c5b72f12d57f45c747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a4bcb30233885d3c5b72f12d57f45c747">clear</a> () noexcept</td></tr>
<tr class="separator:a4bcb30233885d3c5b72f12d57f45c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea1f2b5f860849652fb907fc6d0118a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#abea1f2b5f860849652fb907fc6d0118a">insert</a> (const <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;value)</td></tr>
<tr class="separator:abea1f2b5f860849652fb907fc6d0118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94549d788d6ad3562fd939122eeb489"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ad94549d788d6ad3562fd939122eeb489">insert</a> (<a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:ad94549d788d6ad3562fd939122eeb489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ec61cd119cb874116836b844d1ae1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a70ec61cd119cb874116836b844d1ae1e">insert</a> (<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> hint, const <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;value)</td></tr>
<tr class="separator:a70ec61cd119cb874116836b844d1ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333db92a40c8bacfb8ac384c139f0902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a333db92a40c8bacfb8ac384c139f0902">insert</a> (<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> hint, <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a333db92a40c8bacfb8ac384c139f0902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592406a5af3bf659246573bb054f5de6"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a592406a5af3bf659246573bb054f5de6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a592406a5af3bf659246573bb054f5de6">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a592406a5af3bf659246573bb054f5de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a9f7ae9e64d54d0056d153d48be140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a63a9f7ae9e64d54d0056d153d48be140">insert</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a63a9f7ae9e64d54d0056d153d48be140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5019af503ae2fb047012823dd2bd269c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a5019af503ae2fb047012823dd2bd269c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a5019af503ae2fb047012823dd2bd269c">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a5019af503ae2fb047012823dd2bd269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91960c44480042438c48bb66c25ba36d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a91960c44480042438c48bb66c25ba36d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a91960c44480042438c48bb66c25ba36d">emplace_hint</a> (<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a91960c44480042438c48bb66c25ba36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e08574fa0df3b2c9f7ced4e7fb9178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ae3e08574fa0df3b2c9f7ced4e7fb9178">erase</a> (<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> pos)</td></tr>
<tr class="separator:ae3e08574fa0df3b2c9f7ced4e7fb9178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921082e3318939af4d2bf83d260fbf70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a921082e3318939af4d2bf83d260fbf70">erase</a> (<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> pos)</td></tr>
<tr class="separator:a921082e3318939af4d2bf83d260fbf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d177d245311d83483ec424ac2b9810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a48d177d245311d83483ec424ac2b9810">erase</a> (<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> first, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> last)</td></tr>
<tr class="separator:a48d177d245311d83483ec424ac2b9810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd4283fc83c34a5d66ad8370d605a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a9dd4283fc83c34a5d66ad8370d605a49">erase</a> (const <a class="el" href="classtsl_1_1sparse__set.html#a134ffc2e98eb4036ec035dcab3311132">key_type</a> &amp;key)</td></tr>
<tr class="separator:a9dd4283fc83c34a5d66ad8370d605a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb2c083504764b48bcf0d500e9aea7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7bb2c083504764b48bcf0d500e9aea7f">erase</a> (const <a class="el" href="classtsl_1_1sparse__set.html#a134ffc2e98eb4036ec035dcab3311132">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a7bb2c083504764b48bcf0d500e9aea7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed691a0f9e58076ff8caa5751720a6b"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ed691a0f9e58076ff8caa5751720a6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a1ed691a0f9e58076ff8caa5751720a6b">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:a1ed691a0f9e58076ff8caa5751720a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c6cab5be7100742daf07c61919649c"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a73c6cab5be7100742daf07c61919649c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a73c6cab5be7100742daf07c61919649c">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a73c6cab5be7100742daf07c61919649c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c58933066eb908e484873ccb0bbb6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a44c58933066eb908e484873ccb0bbb6c">swap</a> (<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;other)</td></tr>
<tr class="separator:a44c58933066eb908e484873ccb0bbb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fd9e9a69c22ece91d0c87e71dc79e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ab7fd9e9a69c22ece91d0c87e71dc79e8">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:ab7fd9e9a69c22ece91d0c87e71dc79e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2130a885e6d366a0811566438e54639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ac2130a885e6d366a0811566438e54639">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:ac2130a885e6d366a0811566438e54639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0f7ac605a262c32cf2aeff6c18232"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ba0f7ac605a262c32cf2aeff6c18232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a5ba0f7ac605a262c32cf2aeff6c18232">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:a5ba0f7ac605a262c32cf2aeff6c18232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600834be6de375e098820963521fce6b"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a600834be6de375e098820963521fce6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a600834be6de375e098820963521fce6b">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a600834be6de375e098820963521fce6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b28bb68886acda070acae5856c3d157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a1b28bb68886acda070acae5856c3d157">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:a1b28bb68886acda070acae5856c3d157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58c965a01755af25985e9561715e678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ad58c965a01755af25985e9561715e678">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:ad58c965a01755af25985e9561715e678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20af8749961a4ecb90cca2c441fe5d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#aa20af8749961a4ecb90cca2c441fe5d3">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:aa20af8749961a4ecb90cca2c441fe5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7801a6ec39a66283c0eb29eda197393f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7801a6ec39a66283c0eb29eda197393f">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a7801a6ec39a66283c0eb29eda197393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74897d83794929d3995f259acee0a850"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a74897d83794929d3995f259acee0a850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a74897d83794929d3995f259acee0a850">find</a> (const K &amp;key)</td></tr>
<tr class="separator:a74897d83794929d3995f259acee0a850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c8f13a523755540e50c42f333739a3"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a50c8f13a523755540e50c42f333739a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a50c8f13a523755540e50c42f333739a3">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a50c8f13a523755540e50c42f333739a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8780021bb88761504597e51f9162913d"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8780021bb88761504597e51f9162913d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a8780021bb88761504597e51f9162913d">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:a8780021bb88761504597e51f9162913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd2be010b35ba82655efcc5633792ee"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9cd2be010b35ba82655efcc5633792ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a9cd2be010b35ba82655efcc5633792ee">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a9cd2be010b35ba82655efcc5633792ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317b17a052155ce992ec6df7b77534b8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a317b17a052155ce992ec6df7b77534b8">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:a317b17a052155ce992ec6df7b77534b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2537ad1b62c61f119d9738fbb4ded4de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a2537ad1b62c61f119d9738fbb4ded4de">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a2537ad1b62c61f119d9738fbb4ded4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6fceedcafe320e6c0a505bc849b822"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a6a6fceedcafe320e6c0a505bc849b822">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a6a6fceedcafe320e6c0a505bc849b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33deaad8c66a861feb28b3def065fb2f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a33deaad8c66a861feb28b3def065fb2f">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a33deaad8c66a861feb28b3def065fb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34331fb4bedeb7535925b40a07901abe"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a34331fb4bedeb7535925b40a07901abe"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a34331fb4bedeb7535925b40a07901abe">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:a34331fb4bedeb7535925b40a07901abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d5aa2c318e38e2ef5a9d754792923"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a183d5aa2c318e38e2ef5a9d754792923"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a183d5aa2c318e38e2ef5a9d754792923">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a183d5aa2c318e38e2ef5a9d754792923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ba8ffaaf989a5294054880479690c4"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a75ba8ffaaf989a5294054880479690c4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a75ba8ffaaf989a5294054880479690c4">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:a75ba8ffaaf989a5294054880479690c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27e947b8bfa254d634334abb090930d"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab27e947b8bfa254d634334abb090930d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ab27e947b8bfa254d634334abb090930d">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:ab27e947b8bfa254d634334abb090930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89c84519f5022844ce48912968a7555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ac89c84519f5022844ce48912968a7555">bucket_count</a> () const</td></tr>
<tr class="separator:ac89c84519f5022844ce48912968a7555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9c97b74a20a47322d6dd10bcb48043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#afd9c97b74a20a47322d6dd10bcb48043">max_bucket_count</a> () const</td></tr>
<tr class="separator:afd9c97b74a20a47322d6dd10bcb48043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e06dbb9040e622a642a4b486bf11de"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ab0e06dbb9040e622a642a4b486bf11de">load_factor</a> () const</td></tr>
<tr class="separator:ab0e06dbb9040e622a642a4b486bf11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c1210b81af6c08ca88b1ccac0bcbf2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a73c1210b81af6c08ca88b1ccac0bcbf2">max_load_factor</a> () const</td></tr>
<tr class="separator:a73c1210b81af6c08ca88b1ccac0bcbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add261b415fe2cd40cadf06ef78e43701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#add261b415fe2cd40cadf06ef78e43701">max_load_factor</a> (float ml)</td></tr>
<tr class="separator:add261b415fe2cd40cadf06ef78e43701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85d31fb27f56741dae9ab4ec5ff1e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a2a85d31fb27f56741dae9ab4ec5ff1e9">rehash</a> (<a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ab7fd9e9a69c22ece91d0c87e71dc79e8">count</a>)</td></tr>
<tr class="separator:a2a85d31fb27f56741dae9ab4ec5ff1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394bc5df326716496d91bb88aadd3e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a394bc5df326716496d91bb88aadd3e2d">reserve</a> (<a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html#ab7fd9e9a69c22ece91d0c87e71dc79e8">count</a>)</td></tr>
<tr class="separator:a394bc5df326716496d91bb88aadd3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2cf93cf5a29e18163079713ef2c233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27c26bba78435b5e2ba52439322b1ecc">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function</a> () const</td></tr>
<tr class="separator:a7e2cf93cf5a29e18163079713ef2c233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad2ca79e832b49ad39e77947de3de0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a2660bae704edd1f398dfbe2088ed38f5">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a8ad2ca79e832b49ad39e77947de3de0f">key_eq</a> () const</td></tr>
<tr class="separator:a8ad2ca79e832b49ad39e77947de3de0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586f1bfad77eb6a7a96c0e264c9ca250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a586f1bfad77eb6a7a96c0e264c9ca250">mutable_iterator</a> (<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> pos)</td></tr>
<tr class="separator:a586f1bfad77eb6a7a96c0e264c9ca250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4ee21aeaf4d1cc2ffde634eb92ba509c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a4ee21aeaf4d1cc2ffde634eb92ba509c">operator==</a> (const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;rhs)</td></tr>
<tr class="separator:a4ee21aeaf4d1cc2ffde634eb92ba509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a023f8e20e3169dd91add1ee70b8a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#a87a023f8e20e3169dd91add1ee70b8a9">operator!=</a> (const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;rhs)</td></tr>
<tr class="separator:a87a023f8e20e3169dd91add1ee70b8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b18f71eaef4292193326023f25dc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1sparse__set.html#ae7b18f71eaef4292193326023f25dc62">swap</a> (<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;lhs, <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> &amp;rhs)</td></tr>
<tr class="separator:ae7b18f71eaef4292193326023f25dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, class GrowthPolicy = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt;<br />
class tsl::sparse_set&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;</h3>

<p>Implementation of a sparse hash set using open-addressing with quadratic probing. The goal on the hash set is to be the most memory efficient possible, even at low load factor, while keeping reasonable performances.</p>
<p><code>GrowthPolicy</code> defines how the set grows and consequently how a hash value is mapped to a bucket. By default the set uses <code><a class="el" href="classtsl_1_1sh_1_1power__of__two__growth__policy.html">tsl::sh::power_of_two_growth_policy</a></code>. This policy keeps the number of buckets to a power of two and uses a mask to map the hash to a bucket instead of the slow modulo. Other growth policies are available and you may define your own growth policy, check <code><a class="el" href="classtsl_1_1sh_1_1power__of__two__growth__policy.html">tsl::sh::power_of_two_growth_policy</a></code> for the interface.</p>
<p><code>ExceptionSafety</code> defines the exception guarantee provided by the class. By default only the basic exception safety is guaranteed which mean that all resources used by the hash set will be freed (no memory leaks) but the hash set may end-up in an undefined state if an exception is thrown (undefined here means that some elements may be missing). This can ONLY happen on rehash (either on insert or if <code>rehash</code> is called explicitly) and will occur if the Allocator can't allocate memory (<code>std::bad_alloc</code>) or if the copy constructor (when a nothrow move constructor is not available) throws and exception. This can be avoided by calling <code>reserve</code> beforehand. This basic guarantee is similar to the one of <code>google::sparse_hash_map</code> and <code>spp::sparse_hash_map</code>. It is possible to ask for the strong exception guarantee with <code><a class="el" href="namespacetsl_1_1sh.html#a0cd6797987a18d737875675e670370f4a6f7f9432d35dea629c8384dab312259a">tsl::sh::exception_safety::strong</a></code>, the drawback is that the set will be slower on rehashes and will also need more memory on rehashes.</p>
<p><code>Sparsity</code> defines how much the hash set will compromise between insertion speed and memory usage. A high sparsity means less memory but longer insertion times, and vice-versa for low sparsity. The default <a class="el" href="namespacetsl_1_1sh.html#ab22afd9f8aba09d8abada8f51dd67539a075a3e36a0a52dcbc568c05788e8a713">tsl::sh::sparsity::medium</a> sparsity offers a good compromise. It doesn't change the lookups speed.</p>
<p>If the destructor of <code>Key</code> throws an exception, the behaviour of the class is undefined.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators.</li>
<li>insert, emplace, emplace_hint: if there is an effective insert, invalidate the iterators.</li>
<li>erase: always invalidate the iterators. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1fd4aa5667d3a2c13c81f65ad0cdcb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd4aa5667d3a2c13c81f65ad0cdcb2f">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a1fd4aa5667d3a2c13c81f65ad0cdcb2f">allocator_type</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a574a1bee2921d635f4f8f95cbb549df6">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4173ab24031bacf64a1d84b57eb56ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4173ab24031bacf64a1d84b57eb56ebf">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aee8a233535786e0a96080bb9b0696f07">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae5e1f0224035d65a46a9496504e2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5e1f0224035d65a46a9496504e2f49">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#aae5e1f0224035d65a46a9496504e2f49">const_pointer</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a487a79ec467016ab14d390c1ac7c5f1b">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a465b2d7e7e411b8be32e2144322fad8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465b2d7e7e411b8be32e2144322fad8c">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a465b2d7e7e411b8be32e2144322fad8c">const_reference</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a7178624912bef125a419abfdf2660e84">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af89fa803460a78b451a8c13fa332d56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89fa803460a78b451a8c13fa332d56e">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#af89fa803460a78b451a8c13fa332d56e">difference_type</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aa2f4501c9b73d199b144bc6184b73fe5">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27c26bba78435b5e2ba52439322b1ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c26bba78435b5e2ba52439322b1ecc">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a27c26bba78435b5e2ba52439322b1ecc">hasher</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a9fca6709214b4c2ced97e25582255437">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27cd3ae31de1ba6d0e63a9f36f8b2a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cd3ae31de1ba6d0e63a9f36f8b2a14">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a7bdadb7941c03e0aa1df91787a3306f2">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2660bae704edd1f398dfbe2088ed38f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2660bae704edd1f398dfbe2088ed38f5">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a2660bae704edd1f398dfbe2088ed38f5">key_equal</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#ab8a7d98af123623e80fdc76508d1ae5a">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a134ffc2e98eb4036ec035dcab3311132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134ffc2e98eb4036ec035dcab3311132">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a134ffc2e98eb4036ec035dcab3311132">key_type</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#adc056738e1cacb38ce79bcb83570295f">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addfe79c23e570b78b5926a1a3289c319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfe79c23e570b78b5926a1a3289c319">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#addfe79c23e570b78b5926a1a3289c319">pointer</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a7c48ae532848dc06f83746a76f060b7d">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af64908d05c7a7d5889afd76531ed80a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64908d05c7a7d5889afd76531ed80a5">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#af64908d05c7a7d5889afd76531ed80a5">reference</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a009f29b7ac5f3cd4fcd1d8984884e65c">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185fabe6ffe0e61cf281fe24dcecb4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185fabe6ffe0e61cf281fe24dcecb4ab">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#a3f4b430ca8f17193795c6c5e47c2761b">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b2a5c6030d9049c3fa90089c44cce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2a5c6030d9049c3fa90089c44cce1c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> =  typename <a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#abf2b27209fb966b4c1bb2a9b079ddd16">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a295f3cff4b99c81bb12798533080d736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295f3cff4b99c81bb12798533080d736">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d46605ff085d7a03a690db6622f21ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d46605ff085d7a03a690db6622f21ec">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a668e9e08cbcd784657b6ac7f5173ac89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e9e08cbcd784657b6ac7f5173ac89">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49356b3874bd2c070e3f486daa9d8c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49356b3874bd2c070e3f486daa9d8c29">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e9295cd2a737df5098cd09ec201c83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9295cd2a737df5098cd09ec201c83c">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4b7aa97ee125f344349ab9e616ab665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b7aa97ee125f344349ab9e616ab665">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aca102c8a2a2f3750ce3815eb06da20ac">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afeca86f7f3d5c2989aed621efa63a2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeca86f7f3d5c2989aed621efa63a2d3">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1449066a67620ccdba8135120161fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1449066a67620ccdba8135120161fd5">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1829a0dbfcb643f6f1e8924f2cbc8a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1829a0dbfcb643f6f1e8924f2cbc8a53">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__sparse__hash_1_1sparse__hash.html#aca102c8a2a2f3750ce3815eb06da20ac">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe15933f44634b22b0f5f4519562856a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe15933f44634b22b0f5f4519562856a">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa07e942615b4e665c237eb5732017cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07e942615b4e665c237eb5732017cd5">&#9670;&nbsp;</a></span>sparse_set() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::<a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c72a399e8dc6d11ec4b556662908aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c72a399e8dc6d11ec4b556662908aa8">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d29d11618e87a80ddbd04467d4a6616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d29d11618e87a80ddbd04467d4a6616">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac89c84519f5022844ce48912968a7555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89c84519f5022844ce48912968a7555">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1a7d7a2675de91621eca5b87ce4cd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a7d7a2675de91621eca5b87ce4cd17">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b70056918da8a673ea4fda6d4275277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b70056918da8a673ea4fda6d4275277">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bcb30233885d3c5b72f12d57f45c747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcb30233885d3c5b72f12d57f45c747">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7fd9e9a69c22ece91d0c87e71dc79e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fd9e9a69c22ece91d0c87e71dc79e8">&#9670;&nbsp;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2130a885e6d366a0811566438e54639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2130a885e6d366a0811566438e54639">&#9670;&nbsp;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a5ba0f7ac605a262c32cf2aeff6c18232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0f7ac605a262c32cf2aeff6c18232">&#9670;&nbsp;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a600834be6de375e098820963521fce6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600834be6de375e098820963521fce6b">&#9670;&nbsp;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a5019af503ae2fb047012823dd2bd269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5019af503ae2fb047012823dd2bd269c">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a91960c44480042438c48bb66c25ba36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91960c44480042438c48bb66c25ba36d">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a40aeb6636b74bdd55e32071df3a281fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aeb6636b74bdd55e32071df3a281fa">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0da9c3e4a3bdbb31d794b5d2bc1d17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da9c3e4a3bdbb31d794b5d2bc1d17f4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aae6b52a13d4789b0ac277e8dad4306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aae6b52a13d4789b0ac277e8dad4306">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a317b17a052155ce992ec6df7b77534b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317b17a052155ce992ec6df7b77534b8">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2537ad1b62c61f119d9738fbb4ded4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2537ad1b62c61f119d9738fbb4ded4de">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a6a6fceedcafe320e6c0a505bc849b822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6fceedcafe320e6c0a505bc849b822">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33deaad8c66a861feb28b3def065fb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33deaad8c66a861feb28b3def065fb2f">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a34331fb4bedeb7535925b40a07901abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34331fb4bedeb7535925b40a07901abe">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a183d5aa2c318e38e2ef5a9d754792923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183d5aa2c318e38e2ef5a9d754792923">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a75ba8ffaaf989a5294054880479690c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ba8ffaaf989a5294054880479690c4">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ab27e947b8bfa254d634334abb090930d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27e947b8bfa254d634334abb090930d">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>, <a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ae3e08574fa0df3b2c9f7ced4e7fb9178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e08574fa0df3b2c9f7ced4e7fb9178">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a921082e3318939af4d2bf83d260fbf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921082e3318939af4d2bf83d260fbf70">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48d177d245311d83483ec424ac2b9810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d177d245311d83483ec424ac2b9810">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dd4283fc83c34a5d66ad8370d605a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd4283fc83c34a5d66ad8370d605a49">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html#a134ffc2e98eb4036ec035dcab3311132">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bb2c083504764b48bcf0d500e9aea7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb2c083504764b48bcf0d500e9aea7f">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html#a134ffc2e98eb4036ec035dcab3311132">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a1ed691a0f9e58076ff8caa5751720a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed691a0f9e58076ff8caa5751720a6b">&#9670;&nbsp;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a73c6cab5be7100742daf07c61919649c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c6cab5be7100742daf07c61919649c">&#9670;&nbsp;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a1b28bb68886acda070acae5856c3d157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b28bb68886acda070acae5856c3d157">&#9670;&nbsp;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad58c965a01755af25985e9561715e678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58c965a01755af25985e9561715e678">&#9670;&nbsp;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="aa20af8749961a4ecb90cca2c441fe5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20af8749961a4ecb90cca2c441fe5d3">&#9670;&nbsp;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7801a6ec39a66283c0eb29eda197393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7801a6ec39a66283c0eb29eda197393f">&#9670;&nbsp;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a74897d83794929d3995f259acee0a850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74897d83794929d3995f259acee0a850">&#9670;&nbsp;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a50c8f13a523755540e50c42f333739a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c8f13a523755540e50c42f333739a3">&#9670;&nbsp;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a8780021bb88761504597e51f9162913d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8780021bb88761504597e51f9162913d">&#9670;&nbsp;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a9cd2be010b35ba82655efcc5633792ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd2be010b35ba82655efcc5633792ee">&#9670;&nbsp;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1sparse__set.html#a7e2cf93cf5a29e18163079713ef2c233">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2d916e767daa8af4521b1eb9a76ef0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d916e767daa8af4521b1eb9a76ef0bf">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a1fd4aa5667d3a2c13c81f65ad0cdcb2f">allocator_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e2cf93cf5a29e18163079713ef2c233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2cf93cf5a29e18163079713ef2c233">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27c26bba78435b5e2ba52439322b1ecc">hasher</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abea1f2b5f860849652fb907fc6d0118a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea1f2b5f860849652fb907fc6d0118a">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94549d788d6ad3562fd939122eeb489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94549d788d6ad3562fd939122eeb489">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70ec61cd119cb874116836b844d1ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ec61cd119cb874116836b844d1ae1e">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a333db92a40c8bacfb8ac384c139f0902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333db92a40c8bacfb8ac384c139f0902">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a592406a5af3bf659246573bb054f5de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592406a5af3bf659246573bb054f5de6">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63a9f7ae9e64d54d0056d153d48be140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a9f7ae9e64d54d0056d153d48be140">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ad2ca79e832b49ad39e77947de3de0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad2ca79e832b49ad39e77947de3de0f">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a2660bae704edd1f398dfbe2088ed38f5">key_equal</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0e06dbb9040e622a642a4b486bf11de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e06dbb9040e622a642a4b486bf11de">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd9c97b74a20a47322d6dd10bcb48043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9c97b74a20a47322d6dd10bcb48043">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73c1210b81af6c08ca88b1ccac0bcbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c1210b81af6c08ca88b1ccac0bcbf2">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add261b415fe2cd40cadf06ef78e43701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add261b415fe2cd40cadf06ef78e43701">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a549f788410854345803c9dfb2ad23b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549f788410854345803c9dfb2ad23b86">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a586f1bfad77eb6a7a96c0e264c9ca250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586f1bfad77eb6a7a96c0e264c9ca250">&#9670;&nbsp;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a27cd3ae31de1ba6d0e63a9f36f8b2a14">iterator</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a4173ab24031bacf64a1d84b57eb56ebf">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a const_iterator to an iterator. </p>

</div>
</div>
<a id="a9dc66404adb78ddce24bc3c163191454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc66404adb78ddce24bc3c163191454">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&amp; <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1sparse__set.html#a7b2a5c6030d9049c3fa90089c44cce1c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a85d31fb27f56741dae9ab4ec5ff1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85d31fb27f56741dae9ab4ec5ff1e9">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a394bc5df326716496d91bb88aadd3e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394bc5df326716496d91bb88aadd3e2d">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03458b16b541626152262a5858e120c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03458b16b541626152262a5858e120c1">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1sparse__set.html#a185fabe6ffe0e61cf281fe24dcecb4ab">size_type</a> <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c58933066eb908e484873ccb0bbb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c58933066eb908e484873ccb0bbb6c">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a87a023f8e20e3169dd91add1ee70b8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a023f8e20e3169dd91add1ee70b8a9">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ee21aeaf4d1cc2ffde634eb92ba509c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee21aeaf4d1cc2ffde634eb92ba509c">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7b18f71eaef4292193326023f25dc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b18f71eaef4292193326023f25dc62">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class GrowthPolicy  = tsl::sh::power_of_two_growth_policy&lt;2&gt;, tsl::sh::exception_safety ExceptionSafety = tsl::sh::exception_safety::basic, tsl::sh::sparsity Sparsity = tsl::sh::sparsity::medium&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1sparse__set.html">sparse_set</a>&lt; Key, Hash, KeyEqual, Allocator, GrowthPolicy, ExceptionSafety, Sparsity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tsl/<a class="el" href="sparse__set_8h_source.html">sparse_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
